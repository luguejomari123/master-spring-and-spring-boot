@RequestMapping(method = RequestMethod.GET, path = "/hello-world")
@GetMapping(path = "/hello-world")

@GetMapping(path = "/hello-world-bean")
public HelloWorldBean helloWorldBean() {
	return new HelloWorldBean("Hello World");
}

Path parameters
@GetMapping(path = "/hello-world/path-variable/{name}")
public HelloWorldBean helloWorldPathVariable(@PathVariable String name) {
	return new HelloWorldBean(String.format("Hello World %s", name));
}

Request Methods
GET - Retrieve details of a resource
POST - Create a new resource
PUT - Update an existing resource
PATCH - Update part of a resource
DELETE - Delete a resource

public User findOne(int id) {
	Predicate<? super User> predicate = user -> user.getId().equals(id); 
	return users.stream().filter(predicate).findFirst().get();
}

@PostMapping("/users")
public void createUser(@RequestBody User user) {
	service.save(user);
}

public User save(User user) {
	user.setId(++usersCount);
	users.add(user);
	return user;
}

response status
resource is not found = 404
server exception = 500
validation error = 400
200 = success
201 = created
204 = no content
401 = unauthorized (when authorization fails)
400 - bad request (such as validation error)
404 - resource not found
500 - server error

@PostMapping("/users")
public ResponseEntity<User> createUser(@RequestBody User user) {
	User savedUser = service.save(user);
	// /users/4 => /users/{id},    user.getId
	URI location = ServletUriComponentsBuilder.fromCurrentRequest()
			.path("/{id}")
			.buildAndExpand(savedUser.getId())
			.toUri();
	return ResponseEntity.created(location).build();
}

@ResponseStatus(code = HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException {

	public UserNotFoundException(String message) {
		super(message);
	}
}

@ControllerAdvice
public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler{
	@ExceptionHandler(Exception.class)
	public final ResponseEntity<ErrorDetails> handleAllExceptions(Exception ex, WebRequest request) throws Exception {
		ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), 
				ex.getMessage(), request.getDescription(false));
		
		return new ResponseEntity<ErrorDetails>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
		
	}
 
	@ExceptionHandler(UserNotFoundException.class)
	public final ResponseEntity<ErrorDetails> handleUserNotFoundException(Exception ex, WebRequest request) throws Exception {
		ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), 
				ex.getMessage(), request.getDescription(false));
		
		return new ResponseEntity<ErrorDetails>(errorDetails, HttpStatus.NOT_FOUND);
	}
	
	@Override
	protected ResponseEntity<Object> handleMethodArgumentNotValid(
			MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {
		ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), 
				ex.getFieldError().getDefaultMessage(), request.getDescription(false));
		
		return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
	}
}

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-validation</artifactId>
</dependency>

@Size(min = 2, message = "Name should have atleast 2 characters")
@Past(message = "Birth Date should be in the past")

<dependency>
	<groupId>org.springdoc</groupId>
	<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
	<version>2.3.0</version>
</dependency>

http://localhost:8080/swagger-ui/index.html

internationalization - i18n
create file called messages.properties
inside contains:
good.morning.message=Good Morning

create file for other languages ex. messages_nl.properies, messages_fr.properties, message_de.properties etc.
replace good.morning.message with equivalent for other languages
good.morning.message=Goedemorgen
good.morning.message=Bonjour
good.morning.message=Guten Morgen


different versioning
@GetMapping("/v1/person")
public PersonV1 getFirstVersionOfPerson() {
	return new PersonV1("Bob Charlie");
}

@GetMapping("/v2/person")
public PersonV2 getSecondVersionOfPerson() {
	return new PersonV2(new Name("Bob","Charlie"));
}

@GetMapping(path="/person", params = "version=1")
public PersonV1 getFirstVersionOfPersonRequestParameter() {
	return new PersonV1("Bob Charlie");
}

@GetMapping(path="/person", params = "version=2")
public PersonV2 getSecondVersionOfPersonRequestParameter() {
	return new PersonV2(new Name("Bob","Charlie"));
}

@GetMapping(path="/person/header", headers = "X-API-VERSION=1")
public PersonV1 getFirstVersionOfPersonRequestHeader() {
	return new PersonV1("Bob Charlie");
}

@GetMapping(path="/person/header", headers = "X-API-VERSION=2")
public PersonV2 getSecondVersionOfPersonRequestHeader() {
	return new PersonV2(new Name("Bob","Charlie"));
}

@GetMapping(path="/person/accept", produces = "application/vnd.company.app-v1+json")
public PersonV1 getFirstVersionOfPersonAcceptHeader() {
	return new PersonV1("Bob Charlie");
}

@GetMapping(path="/person/accept", produces = "application/vnd.company.app-v2+json")
public PersonV2 getSecondVersionOfPersonAcceptHeader() {
	return new PersonV2(new Name("Bob","Charlie"));
}

HATEOAS - hypermedia as the engine of application state
@GetMapping("/users/{id}")
public EntityModel<User> retrieveUser(@PathVariable int id){
	User user = service.findOne(id);
	
	if(user == null)
		throw new UserNotFoundException("id:"+id);
	
	EntityModel<User> entityModel = EntityModel.of(user);
	
	return entityModel;
}

customizing rest api response
1. Customize field names in response
    - @JSONProperty
2. Return only selected fields
    - Filtering
	static filtering - @JsonIgnore=added to member, @JsonIgnoreProperties("propertyname") = added to class
	dynamic filtering - @JsonFilter with FilterProvider
	
	private MappingJacksonValue createMappingJackSonValue(Object value, String filterId, String... propertyArray) {
		MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(value);
		SimpleBeanPropertyFilter filter = SimpleBeanPropertyFilter.filterOutAllExcept(propertyArray);
		FilterProvider filters = new SimpleFilterProvider().addFilter(filterId, filter );
		mappingJacksonValue.setFilters(filters);
		
		return mappingJacksonValue;
	}
	
HAL explorer
<dependency>
	<groupId>org.springframework.data</groupId>
	<artifactId>spring-data-rest-hal-explorer</artifactId>
</dependency>